#ifndef ARM_OPTIMIZED_MATH
#define ARM_OPTIMIZED_MATH

#include <stdint.h>
#define float32_t float
#include "commonmath.h"
	
typedef struct sARM__Var
{
  const float twotokover4top[4] = { 0x1p+0F, 0x1.306p+0F, 0x1.6ap+0F, 0x1.ae8p+0F };
const float twotokover4bot[4] = { 0x0p+0F, 0x1.fc1464p-13F, 0x1.3cccfep-13F, 0x1.3f32b6p-13F };
const float twotokover4all[4] = { 0x1p+0F, 0x1.306fep+0F, 0x1.6a09e6p+0F, 0x1.ae89fap+0F };

static constexpr const float log2hi = 0x1.62ep-1F, 
						                 log2lo = 0x1.0bfbe8p-15F;
const float logahi[8] = { 0x0p+0F, 0x1.e26p-4F, 0x1.c8ep-3F, 0x1.46p-2F, 0x1.9f2p-2F, 0x1.f12p-2F, 0x1.1e8p-1F, 0x1.41cp-1F };
const float logalo[8] = { 0x0p+0F, 0x1.076e2ap-16F, 0x1.f7c79ap-15F, 0x1.8bc21cp-14F, 0x1.23eccp-14F, 0x1.1ebf5ep-15F, 0x1.7d79c2p-15F, 0x1.8fe846p-13F };

} sARM__Var;
extern sARM__Var const ARM__Var
	__attribute__((aligned(ARMV7M_DCACHE_LINESIZE))) 							// used a lot
	__attribute__((section (".dtcm_const")));

//#define __FP_IEEE
//#define __FP_FENV_EXCEPTIONS
//#define __FP_FENV_ROUNDING
//#define __FP_INEXACT_EXCEPTION

//#define __set_errno(val) (errno = (val))

#define __FLT(x) (*(unsigned *)&(x))
#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
#  define __LO(x) (*(1 + (unsigned *)&(x)))
#  define __HI(x) (*(unsigned *)&(x))
#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
#  define __HI(x) (*(1 + (unsigned *)&(x)))
#  define __LO(x) (*(unsigned *)&(x))
#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */

// FIXME: Implement these without type punning.
STATIC_INLINE_PURE unsigned int const fai(float const f) { return(__FLT(f)); }
STATIC_INLINE_PURE float const fhex(unsigned int const n) { float f; __FLT(f) = n; return(f); }

#define CLEARBOTTOMHALF(x) fhex((fai(x) + 0x00000800) & 0xFFFFF000)
#define MATHERR_LOGF_0(x) (/*__set_errno(ERANGE),*/ x/*-FLOAT_DIVZERO*/)
#define MATHERR_LOGF_NEG(x) (/*__set_errno(EDOM),*/ x/*FLOAT_INVALID*/)

#define MATHERR_EXPF_UFL(x) (/*__set_errno(ERANGE),*/ x/*, FLOAT_UNDERFLOW*/)
#define MATHERR_EXPF_OFL(x) (/*__set_errno(ERANGE),*/ x/*, FLOAT_OVERFLOW*/)

#define FLOAT_CHECKDENORM(x) ( /*(fpclassify(x) == FP_SUBNORMAL ? 0 : 0),*/ x )

//STATIC_INLINE __attribute__((const)) float const ARM__expf(float X);
//STATIC_INLINE __attribute__((const)) float const ARM__logf(float X);
	 

STATIC_INLINE __attribute__((const)) float const ARM__expf(float const X)
{	
	static constexpr uint32_t const BUILTIN_EXPECT_THRESHOLD = 0x85500000 - 0x67000000;
	static constexpr float const SPLIT_CONSTANT = 4.0f*1.4426950408889634074f;
	
  int N; float XN, g, Rg, Result;
  unsigned int ix = fai(X), edgecaseflag = 0;

  /*
   * Handle infinities, NaNs and big numbers.
   */
  if (__builtin_expect((ix << 1) - 0x67000000 > BUILTIN_EXPECT_THRESHOLD, 0)) {
    if (!(0x7f800000 & ~ix)) {
      if (ix == 0xff800000)
        return(0.0f);
      else
        return( 0.0f /* FLOAT_INFNAN(X) */ );/* do the right thing with both kinds of NaN and with +inf */
    } else if ((ix << 1) < 0x67000000) {
      return(1.0f);               /* magnitude so small the answer can't be distinguished from 1 */
    } else if ((ix << 1) > 0x85a00000) {
      //__set_errno(ERANGE);
      if (ix & 0x80000000) {
        return( 0.0f/*FLOAT_UNDERFLOW*/ );
      } else {
        return( 0.0f/*FLOAT_OVERFLOW */);
      }
    } else {
      edgecaseflag = 1;
    }
  }

  /*
   * Split the input into an integer multiple of log(2)/4, and a
   * fractional part.
   */
  XN = X * SPLIT_CONSTANT;

	XN = float32::__floorf(XN + (ix & 0x80000000 ? -0.5f : 0.5f));
  N = XN;
  
  g = (X - XN * 0x1.62ep-3F) - XN * 0x1.0bfbe8p-17F;  /* prec-and-a-half representation of log(2)/4 */
	//g = (X - XN * /*0x1.62ep-3F*/0.173279f) - XN * /*0x1.0bfbe8p-17F*/7.98655e-06f;  /* prec-and-a-half representation of log(2)/4 */

  /*
   * Now we compute exp(X) in, conceptually, three parts:
   *  - a pure power of two which we get from N>>2
   *  - exp(g) for g in [-log(2)/8,+log(2)/8], which we compute
   *    using a Remez-generated polynomial approximation
   *  - exp(k*log(2)/4) (aka 2^(k/4)) for k in [0..3], which we
   *    get from a lookup table in precision-and-a-half and
   *    multiply by g.
   *
   * We gain a bit of extra precision by the fact that actually
   * our polynomial approximation gives us exp(g)-1, and we add
   * the 1 back on by tweaking the prec-and-a-half multiplication
   * step.
   *
   * Coefficients generated by the command
./auxiliary/remez.jl --variable=g --suffix=f -- '-log(BigFloat(2))/8' '+log(BigFloat(2))/8' 3 0 '(expm1(x))/x'
  */
  Rg = g * (
            
						__fma(g,
						__fma(g,
						__fma(g, 4.168230895653321517750133783431970715648192153539929404872173693978116154823859e-02f, 
										 1.667292360203016574303631953046104769969440903672618034272397630620346717392378e-01f),
									4.999999608551332693833317084753864837160947932961832943901913087652889900683833e-01f),
									9.999999412829185331953781321128516523408059996430919985217971370689774264850229e-01f)
									
            );

  /*
   * Do the table lookup and combine it with Rg, to get our final
   * answer apart from the exponent.
   */
  {
    int const index( (N & 3) );
    Rg = __fma(Rg, ARM__Var.twotokover4all[index], ARM__Var.twotokover4top[index] + ARM__Var.twotokover4bot[index]);
    N >>= 2;
  }

  /*
   * Combine the output exponent and mantissa, and return.
   */
  if (__builtin_expect(edgecaseflag, 0)) {
    Result = fhex(((N>>1) << 23) + 0x3f800000);
    Result *= Rg;
    Result *= fhex(((N-(N>>1)) << 23) + 0x3f800000);
    /*
     * Step not mentioned in C&W: set errno reliably.
     */
    if (fai(Result) == 0)
      return( MATHERR_EXPF_UFL(Result) );
    if (fai(Result) == 0x7f800000)
      return( MATHERR_EXPF_OFL(Result) );
    return( FLOAT_CHECKDENORM(Result) );
  } else {
		constexpr float const fadd((float)0x3f800000);
    Result = fhex(N * 8388608.0f + fadd);
    Result *= Rg;
  }

  return(Result);
}


STATIC_INLINE __attribute__((const)) float const ARM__logf(float X)
{
	static constexpr uint32_t const BUILTIN_EXPECT_THRESHOLD = 0x7f800000 - 0x00800000;
	
    int N = 0;
    int aindex;
    float a, x, s;
    unsigned ix = fai(X);

    if (__builtin_expect((ix - 0x00800000) >= BUILTIN_EXPECT_THRESHOLD, 0)) {
        if ((ix << 1) > 0xff000000) /* NaN */
            return( 0.0f /*FLOAT_INFNAN(X)*/ );
        if (ix == 0x7f800000)          /* +inf */
            return X;
        if (X < 0) {                   /* anything negative */
            return MATHERR_LOGF_NEG(X);
        }
        if (X == 0) {
            return MATHERR_LOGF_0(X);
        }
        /* That leaves denormals. */
       // N = -23;
       // X *= 0x1p+23F;
       // ix = fai(X);
    }

    /*
     * Separate X into three parts:
     *  - 2^N for some integer N
     *  - a number a of the form (1+k/8) for k=0,...,7
     *  - a residual which we compute as s = (x-a)/(x+a), for
     *    x=X/2^N.
     *
     * We pick the _nearest_ (N,a) pair, so that (x-a) has magnitude
     * at most 1/16. Hence, we must round things that are just
     * _below_ a power of two up to the next power of two, so this
     * isn't as simple as extracting the raw exponent of the FP
     * number. Instead we must grab the exponent together with the
     * top few bits of the mantissa, and round (in integers) there.
     */
    {
        int rounded = ix + 0x00080000;
        int Nnew = (rounded >> 23) - 127;
        aindex = (rounded >> 20) & 7;
        a = fhex(0x3f800000 + (aindex << 20));
        N += Nnew;
        x = fhex(ix - (Nnew << 23));
    }

    if (!N && !aindex) {
        /*
         * Use an alternative strategy for very small |x|, which
         * avoids the 1ULP of relative error introduced in the
         * computation of s. If our nearest (N,a) pair is N=0,a=1,
         * that means we have -1/32 < x-a < 1/16, on which interval
         * the ordinary series for log(1+z) (setting z-x-a) will
         * converge adequately fast; so we can simply find an
         * approximation to log(1+z)/z good on that interval and
         * scale it by z on the way out.
         *
         * Coefficients generated by the command
./auxiliary/remez.jl --variable=z --suffix=f -- '-1/BigFloat(32)' '+1/BigFloat(16)' 3 0 '(log1p(x)-x)/x^2'
         */
        float z = x - 1.0f;
        float p = z*z * (
            -4.999999767382730053173434595877399055021398381370452534949864039404089549132551e-01f+z*(3.333416379155995401749506866323446447523793085809161350343357014272193712456391e-01f+z*(-2.501299948811686421962724839011563450757435183422532362736159418564644404218257e-01f+z*(1.903576945606738444146078468935429697455230136403008172485495359631510244557255e-01f)))
            );

        return z + p;
    }

    /*
     * Now we have N, a and x correct, so that |x-a| <= 1/16.
     * Compute s.
     *
     * (Since |x+a| >= 2, this means that |s| will be at most 1/32.)
     */
    s = (x - a) / (x + a);

    /*
     * The point of computing s = (x-a)/(x+a) was that this makes x
     * equal to a * (1+s)/(1-s). So we can now compute log(x) by
     * means of computing log((1+s)/(1-s)) (which has a more
     * efficiently converging series), and adding log(a) which we
     * obtain from a lookup table.
     *
     * So our full answer to log(X) is now formed by adding together
     * N*log(2) + log(a) + log((1+s)/(1-s)).
     *
     * Now log((1+s)/(1-s)) has the exact Taylor series
     *
     *   2s + 2s^3/3 + 2s^5/5 + ...
     *
     * and what we do is to compute all but the first term of that
     * as a polynomial approximation in s^2, then add on the first
     * term - and all the other bits and pieces above - in
     * precision-and-a-half so as to keep the total error down.
     */
    {
        float s2 = s*s;

        /*
         * We want a polynomial L(s^2) such that
         *
         *    2s + s^3*L(s^2) = log((1+s)/(1-s))
         *
         * => L(s^2) = (log((1+s)/(1-s)) - 2s) / s^3
         *
         * => L(z) = (log((1+sqrt(z))/(1-sqrt(z))) - 2*sqrt(z)) / sqrt(z)^3
         *
         * The required range of the polynomial is only [0,1/32^2].
         *
         * Our accuracy requirement for the polynomial approximation
         * is that we don't want to introduce any error more than
         * about 2^-23 times the _top_ bit of s. But the value of
         * the polynomial has magnitude about s^3; and since |s| <
         * 2^-5, this gives us |s^3/s| < 2^-10. In other words,
         * our approximation only needs to be accurate to 13 bits or
         * so before its error is lost in the noise when we add it
         * to everything else.
         *
         * Coefficients generated by the command
./auxiliary/remez.jl --variable=s2 --suffix=f -- '0' '1/BigFloat(32^2)' 1 0 '(abs(x) < 1e-20 ? BigFloat(2)/3 + 2*x/5 + 2*x^2/7 + 2*x^3/9 : (log((1+sqrt(x))/(1-sqrt(x)))-2*sqrt(x))/sqrt(x^3))'
         */
        float const p = s * s2 * (
            __fma(s2 , 4.002792299542401431889592846825025487338520940900492146195427243856292349188402e-01f, 6.666666325680271091157649745099739739798210281016897722498744752867165138320995e-01f)
            );

        return (N*ARM__Var.log2hi + ARM__Var.logahi[aindex]) + (2.0f*s + (N*ARM__Var.log2lo + ARM__Var.logalo[aindex] + p));
    }
}

#ifdef FAST_MATH_TABLE_SIZE
#undef FAST_MATH_TABLE_SIZE
#endif
static constexpr uint32_t const FAST_MATH_TABLE_SIZE = 512;
extern float32_t const sinTable_f32[FAST_MATH_TABLE_SIZE + 1]
	__attribute__((aligned(ARMV7M_DCACHE_LINESIZE))) 							// used a lot
	__attribute__((section (".dtcm_const")));

STATIC_INLINE __attribute__((const)) float const ARM__cosf(float in)
{
  float32_t cosVal, fract;                   /* Temporary variables for input, output */
  uint16_t index;                                /* Index variable */
  float32_t a, b;                                /* Two nearest output values */

  float32_t findex;

  /* input x is in radians */
  /* Scale the input to [0 1] range from [0 2*PI] , divide input by 2*pi, add 0.25 (pi/2) to read sine table */
  in = __fma(in, 0.159154943092f, 0.25f);

  /* Calculation of floor value of input */
  /* Map input value to [0 1] */
  in = __sfractf(in);

  /* Calculation of index of the table */
  findex = (float32_t) FAST_MATH_TABLE_SIZE * in;
  index = ((uint16_t)findex) & 0x1ff;

  /* fractional value calculation */
  fract = findex - (float32_t) index;

  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];

  /* Linear interpolation process */
  cosVal = __fma(1.0f-fract, a, fract*b);

  /* Return the output value */
  return (cosVal);
}

STATIC_INLINE __attribute__((const)) float const ARM__sinf(float in)
{
	float32_t sinVal, fract;                           /* Temporary variables for input, output */
  uint16_t index;                                        /* Index variable */
  float32_t a, b;                                        /* Two nearest output values */

  float32_t findex;

  /* Special case for small negative inputs */
  if ((in < 0.0f) && (in >= -1.9e-7f)) {
     return(in);
  }

  /* input x is in radians */
  /* Scale the input to [0 1] range from [0 2*PI] , divide input by 2*pi */
  in = in * 0.159154943092f;

  /* Calculation of floor value of input */
  /* Map input value to [0 1] */
  in = __sfractf(in);

  /* Calculation of index of the table */
  findex = (float32_t) FAST_MATH_TABLE_SIZE * in;

  index = ((uint16_t)findex) & 0x1ff;

  /* fractional value calculation */
  fract = findex - (float32_t) index;

  /* Read two nearest values of input value from the sin table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];

  /* Linear interpolation process */
  sinVal = __fma(1.0f-fract, a, fract*b);

  /* Return the output value */
  return (sinVal);
}

STATIC_INLINE void ARM__sincosf
	 (
									float32_t const theta,
									float32_t * const __restrict pSinVal,
									float32_t * const __restrict pCosVal)
{
    float32_t fract, in;                             /* Temporary variables for input, output */
    uint16_t indexS, indexC;                         /* Index variable */
    float32_t f1, f2, d1, d2;                        /* Two nearest output values */
    float32_t findex, Dn, Df, temp;

    /* input x is in degrees */
    /* Scale the input, divide input by 360, for cosine add 0.25 (pi/2) to read sine table */
		in = __fabsf(theta * 0.00277777777778f);

		in = __sfractf(in);

    /* Calculation of index of the table */
    findex = (float32_t) FAST_MATH_TABLE_SIZE * in;
    indexS = ((uint16_t)findex) & 0x1ff;
    indexC = (indexS + (FAST_MATH_TABLE_SIZE >> 2)) & 0x1ff;

    /* fractional value calculation */
    fract = findex - (float32_t) indexS;

    /* Read two nearest values of input value from the cos & sin tables */
    f1 = sinTable_f32[indexC+0];
    f2 = sinTable_f32[indexC+1];
    d1 = -sinTable_f32[indexS+0];
    d2 = -sinTable_f32[indexS+1];

    temp = __fma(1.0f - fract, f1, fract * f2);

    Dn = 0.0122718463030f; // delta between the two points (fixed), in this case 2*pi/FAST_MATH_TABLE_SIZE
    Df = f2 - f1;          // delta between the values of the functions

    temp = __fms(Dn, (d1 + d2), 2.0f * Df);
    temp = __fma(fract, temp, __fms(3.0f, Df, (d2 + 2.0f * d1) * Dn));
    temp = __fma(fract, temp, d1 * Dn);

    /* Calculation of cosine value */
    *pCosVal = __fma(fract, temp, f1);

    /* Read two nearest values of input value from the cos & sin tables */
    f1 = sinTable_f32[indexS+0];
    f2 = sinTable_f32[indexS+1];
    d1 = sinTable_f32[indexC+0];
    d2 = sinTable_f32[indexC+1];

    temp = __fma(1.0f - fract, f1, fract * f2);

    Df = f2 - f1; // delta between the values of the functions
    temp = __fms(Dn, (d1 + d2), 2.0f * Df);
    temp = __fma(fract, temp, __fms(3.0f, Df, (d2 + 2.0f * d1) * Dn));
    temp = __fma(fract, temp, d1 * Dn);

    /* Calculation of sine value */
    if (theta < 0.0f)
        *pSinVal = -__fma(fract, temp, f1);
		else
				*pSinVal = __fma(fract, temp, f1);
}

#define __expf ARM__expf
#define __logf ARM__logf
#define __sinf ARM__sinf
#define __cosf ARM__cosf
#define __sincosf ARM__sincosf

__attribute__((always_inline)) STATIC_INLINE_PURE float32_t const __powf(float32_t const Sn, float32_t const Sm) 
{
	// (still very accurate) fastest powf
  return( ARM__expf(Sm * ARM__logf(Sn)) );
}

STATIC_INLINE_PURE float const FLOAT_to_SRGB(float val)
{
	if (val < 0.0031308f)
		val *= 12.92f;
	else
		val = 1.055f * __powf(val, 1.0f / 2.4f) - 0.055f;

	return (val);
}
#endif

