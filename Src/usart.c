/* Copyright (C) 20xx Jason Tully - All Rights Reserved
 * You may use, distribute and modify this code under the
 * terms of the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License
 * http://www.supersinfulsilicon.com/
 *
This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/
or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 */

#include "usart.h"
#if( 0 != USART_ENABLE )
#include "globals.h"
#include "stm32f7xx_ll_usart.h"
#include "stm32f7xx_ll_dma.h"
#include "stm32f7xx_ll_rcc.h"
#include "stm32f7xx_ll_bus.h"
#include "stm32f7xx_ll_gpio.h"
#include "rng.h"

#include "debug.cpp"

//extern "C" void asmConv_L8L8L8L8_To_L8(uint8_t* __restrict outputL8, uint32_t const* __restrict inputLumaReplicated, uint32_t length);


#define BAUD_RATE (2000000)		// 115200, 921600, 1843200, 2000000

static constexpr uint32_t const FrameBufferLength = ( (OLED::SCREEN_HEIGHT * OLED::SCREEN_WIDTH) >> 1 ); // 4bit framebuffer
static constexpr uint32_t const FrameDataLength = 4096;
static constexpr uint32_t const NumDataFrames = FrameBufferLength / FrameDataLength;

// tags should be in the same order as header types
#define TAG_HEADER_ID_BASE (0xD6U)
#define TAG_HEADER_FRAMEBUFFER (TAG_HEADER_ID_BASE + 0U)

#define TAG_HEADER_MASK (0xFF000000U)
#define TRUE_RANDOM_MASK (0x00FF0000U)
#define HASH_MASK (0x0000FFFFU)
#define HASH_KEY_SEED (0xF5651331)

typedef struct __attribute__((packed, aligned(1))) sUSART_Tx
{
	// purpose: first byte is to be found and aligns start of packet by reciever
	// first byte is only 256 values, could possibly have a invalid data without further hardening, so....
	// second byte is generated by transmitter, and used by reciever as a seed for the final validation step
	// of compariung the 16bit Psudeo random number for equality, which will be the same on both machines if true
	// this hardens the data from being invalid by 256 times 65536 = 16.77e6, so 1 : 16,777,000 chance of having a invalid data packet
	// much better than 1: 256 chance with static header. The 1 : 16.7e6 chance is probably even greater due to validation sequence
	// header byte compare, seed byte, psuedo gen from seed byte, psuedo compare
	// note: psuedo random number generators of both machines must be the same (xorshift implementation used)
	
	uint32_t				Header;								// First MSB Byte is TAG_HEADER_****, mask: (0xFF000000)
																				// Second MSB Byte is True Random Number in range of 0 - 255, used as seed for next... mask: (0x00FF0000)
																				// Remaining 2 Bytes is Hash of TRNG number generated from seed
	
	volatile uint8_t FrameIndex;								// 0 - 255 Frame Index
	uint8_t					 FrameData[FrameDataLength];		// Data Frame
	
} USART_Tx;

static struct
{
	volatile uint32_t Timestamp[2];
	
	volatile bool bRequestDMA_DoubleBuffer[2];
	volatile bool bDMABusy_DoubleBuffer[2];
	
} oUSART;

static USART_Tx oSendTxDoubleBuffer[2]
		__attribute__((section (".ext_sram.usartdoublebuffer"))); // only room left in external sram, 32KB used
static uint8_t oSavedFrameBuffer[2][FrameBufferLength];

// captures only the working "window" from the 4bit dithertarget franebuffer
// there is 56 pixels padding on either side (x-axcs) on the final OLED framebuffer
STATIC_INLINE void PrepareFrameBuffer(uint8_t* __restrict outFrameBuffer, uint8_t const * inFrameBuffer)
{
	static constexpr uint32_t const SideOffset = 56;
	static constexpr uint32_t const Width4bit = (480>>1), Width = 128, Height = 64;
	
	int32_t yPixel = Height - 1;
	do
	{
		
		int32_t xPixel = Width - 1;
		do
		{
			uint32_t const indexIn = (yPixel * Width4bit) + SideOffset + xPixel;
			uint8_t const byte = *(inFrameBuffer + indexIn);
			
			*(outFrameBuffer++) = byte;
			
		} while ( --xPixel >= 0 );
	
	} while ( --yPixel >= 0 );
	
	//Convert from ARGB8888 (Replicated L8) to L8 for send
	// works for 8bit asmConv_L8L8L8L8_To_L8(outFrameBuffer, (uint32_t const* const)inFrameBuffer, FrameBufferLength);
}




void PrepareFrame( USART_Tx* const __restrict txFrame, uint8_t const (&oSourceSavedFrameBuffer)[FrameBufferLength] )
{
	uint32_t const offset = txFrame->FrameIndex * FrameDataLength;
	memcpy8(txFrame->FrameData, oSourceSavedFrameBuffer + offset, FrameDataLength);
}

namespace USART
{

void PushFrameBuffer( uint8_t const* const __restrict DitherTarget )
{
	static uint32_t TimestampPushes = 0;
	
	uint32_t FreeDoubleBuffer;
	
	if ( false == ( oUSART.bRequestDMA_DoubleBuffer[0] | oUSART.bDMABusy_DoubleBuffer[0] )) {
		FreeDoubleBuffer = 0;
	}
	else if ( false == ( oUSART.bRequestDMA_DoubleBuffer[1] | oUSART.bDMABusy_DoubleBuffer[1] )) {
		FreeDoubleBuffer = 1;
	}
	else {
		// drop this point from being sent as to not block the caller (never wait)
		return;
	}
		
	USART_Tx* const __restrict oSend_Tx = &oSendTxDoubleBuffer[FreeDoubleBuffer];
	
	// Header Generation //
	uint32_t const Seed = RandomNumber16(0, UINT8_MAX); // generate true random seed
	
	HashSetSeed(HASH_KEY_SEED);
	
	uint32_t HashSeed = Hash(Seed);
	HashSeed = (HASH_MASK & (((int32_t)HashSeed) >= 0 ? HashSeed >> 16 : HashSeed));
	
	uint32_t Header = HashSeed;

	Header |= (uint32_t const)(TAG_HEADER_FRAMEBUFFER << 24);	// tag header type
	Header |= ( Seed << 16 ); // seed
	
	oSend_Tx->Header = Header; // set header
	
	// *************** copy framebuffer (convert from 4bit grayscale buffer
	PrepareFrameBuffer(oSavedFrameBuffer[FreeDoubleBuffer], DitherTarget);

	oSend_Tx->FrameIndex = 0;
	
	TimestampPushes = (TimestampPushes + 2) | 1; // must be odd for bitband trick
	oUSART.Timestamp[FreeDoubleBuffer] = TimestampPushes;
	
	oUSART.bRequestDMA_DoubleBuffer[FreeDoubleBuffer] = true;
}

void ProcessUSARTDoubleBuffer(void)
{
	// only if dma is free to use
	//if ( false == (oUSART.bDMABusy_DoubleBuffer[0] & oUSART.bDMABusy_DoubleBuffer[1]) )
	if ( 0 == LL_DMA_IsEnabledStream(DMA1, LL_DMA_STREAM_3) )
	{
		// Pending to send
		
		// pick one with a : non-zero timestamp, FIFO - oldest timestamp is the current buffer index for this completion
		bool const bPendingDoubleBuffer[2] = { (bool const)(oUSART.bRequestDMA_DoubleBuffer[0] & (0 != oUSART.Timestamp[0])), 
																					 (bool const)(oUSART.bRequestDMA_DoubleBuffer[1] & (0 != oUSART.Timestamp[1])) };
		
		uint32_t Selected;
		if ( false != (bPendingDoubleBuffer[0] & bPendingDoubleBuffer[1]) ) {
			if ( oUSART.Timestamp[0] < oUSART.Timestamp[1] )
				Selected = 0;
			else
				Selected = 1;
		}
		else if ( bPendingDoubleBuffer[0] )
			Selected = 0;
		else if ( bPendingDoubleBuffer[1] )
			Selected = 1;
		else
			return; // nothing pending
	
		// Send data
		oUSART.bDMABusy_DoubleBuffer[Selected] = true;
		
		PrepareFrame(&oSendTxDoubleBuffer[Selected], oSavedFrameBuffer[Selected]);
		SCB_CleanDCache_by_Addr((uint32_t*)&oSendTxDoubleBuffer[Selected], sizeof(USART_Tx));  // ### working without ? is it config'd WT?
		
		LL_DMA_SetChannelSelection(DMA1, LL_DMA_STREAM_3, LL_DMA_CHANNEL_4);
		LL_DMA_ConfigTransfer(DMA1, LL_DMA_STREAM_3, 
                        LL_DMA_DIRECTION_MEMORY_TO_PERIPH | 
                        LL_DMA_PRIORITY_LOW               | 
                        LL_DMA_MODE_NORMAL                | 
                        LL_DMA_PERIPH_NOINCREMENT         | 
                        LL_DMA_MEMORY_INCREMENT           | 
                        LL_DMA_PDATAALIGN_BYTE            | 
                        LL_DMA_MDATAALIGN_BYTE);
		
		LL_DMA_ConfigAddresses(DMA1, LL_DMA_STREAM_3,
                         (uint32_t)&oSendTxDoubleBuffer[Selected],
                         LL_USART_DMA_GetRegAddr(USART3, LL_USART_DMA_REG_DATA_TRANSMIT),
                         LL_DMA_GetDataTransferDirection(DMA1, LL_DMA_STREAM_3));
		
		LL_DMA_SetDataLength(DMA1, LL_DMA_STREAM_3, sizeof(USART_Tx));
		
		LL_DMA_EnableIT_TC(DMA1, LL_DMA_STREAM_3);
		LL_DMA_DisableIT_TE(DMA1, LL_DMA_STREAM_3);
		
		// TXE
		/* Enable DMA1 Tx Stream */
		LL_USART_EnableDMAReq_TX(USART3);
		LL_DMA_EnableStream(DMA1, LL_DMA_STREAM_3);
	}
}

NOINLINE void InitUSART(void)
{
	oUSART.bRequestDMA_DoubleBuffer[0] = oUSART.bRequestDMA_DoubleBuffer[1] = false;
	
	oUSART.bDMABusy_DoubleBuffer[0] = oUSART.bDMABusy_DoubleBuffer[1] = false;
	
	oUSART.Timestamp[0] = 0;
	oUSART.Timestamp[1] = 0;
	
	LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);  // By defaulr, only dma2 is enabled in dma.c
	NVIC_SetPriority(DMA1_Stream3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),NVIC_PRIORITY_LOW, 0));
  NVIC_EnableIRQ(DMA1_Stream3_IRQn);
	
	/* (2) Enable USART3 peripheral clock and clock source ****************/
  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART3);

  /* Set clock source */
	// bugfix: seems all noise / corrupt data problems are solved with using HSI clk
	// working up to 1843200 BAUD!! @ 8 oversampling
  LL_RCC_SetUSARTClockSource(LL_RCC_USART3_CLKSOURCE_HSI/*LL_RCC_USART3_CLKSOURCE_PCLK1*/);  
	
	{
		/**USART3 GPIO Configuration  
		PD8   ------> USART3_TX
		*/
		//LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);

		/* Configure Tx Pin as : Alternate function, High Speed, Push pull, Pull up */
		LL_GPIO_SetPinMode(GPIOD, LL_GPIO_PIN_8, LL_GPIO_MODE_ALTERNATE);
		LL_GPIO_SetAFPin_8_15(GPIOD, LL_GPIO_PIN_8, LL_GPIO_AF_7);
		LL_GPIO_SetPinSpeed(GPIOD, LL_GPIO_PIN_8, LL_GPIO_SPEED_FREQ_VERY_HIGH); // LL_GPIO_SPEED_FREQ_VERY_HIGH = higher voltage / current
		LL_GPIO_SetPinOutputType(GPIOD, LL_GPIO_PIN_8, LL_GPIO_OUTPUT_PUSHPULL);
		LL_GPIO_SetPinPull(GPIOD, LL_GPIO_PIN_8, LL_GPIO_PULL_NO);
	}
	
	/* TX/RX direction */
  LL_USART_SetTransferDirection(USART3, LL_USART_DIRECTION_TX);

  /* 8 data bit, 1 start bit, 1 stop bit, no parity */
  LL_USART_ConfigCharacter(USART3, LL_USART_DATAWIDTH_8B, LL_USART_PARITY_NONE, LL_USART_STOPBITS_1);
	
	/* Set Baudrate to 115200 using APB frequency set to 54000000 Hz */
  /* Frequency available for USART peripheral can also be calculated through LL RCC macro */
  /* Ex :
      Periphclk = LL_RCC_GetUSARTClockFreq(Instance); or LL_RCC_GetUARTClockFreq(Instance); depending on USART/UART instance
  
      In this example, Peripheral Clock is expected to be equal to 54000000 Hz => equal to SystemCoreClock/4
  */
  LL_USART_SetBaudRate(USART3, LL_RCC_GetUSARTClockFreq(LL_RCC_USART3_CLKSOURCE), LL_USART_OVERSAMPLING_8, BAUD_RATE); 

	LL_USART_ConfigAsyncMode(USART3);
	
  /* (4) Enable USART3 **********************************************************/
  LL_USART_Enable(USART3);
	
  /* Polling USART initialisation */
  while(!LL_USART_IsActiveFlag_TEACK(USART3))
  { 
  }

}

NOINLINE void DebugStartUp(void)
{
	// Header Generation //
	uint32_t const Seed = 100; // generate true random seed
	
	HashSetSeed(HASH_KEY_SEED);
	
	uint32_t HashSeed = Hash(Seed);
	HashSeed = (HASH_MASK & (((int32_t)HashSeed) >= 0 ? HashSeed >> 16 : HashSeed));
	
	PsuedoResetSeed();
	// cnt: 17697, hsh: 0x791A, no match on psuedo btwn machines (due to sequence of random numbers being used, # of them used until this point)
	DebugMessage("( USART, hsh: %02X   psuedo: %04X )", HashSeed, PsuedoRandomNumber16(0, UINT16_MAX) );
}


} // end ns USART

void USARTComplete_DMA1(void)
{		
	// TXE
	/* Disable DMA1 Tx Stream */
	LL_USART_DisableDMAReq_TX(USART3);
	LL_DMA_DisableStream(DMA1, LL_DMA_STREAM_3);
	
	// Reset doublebuffer busy flag
	// pick one with a : non-zero timestamp, FIFO - oldest timestamp is the current buffer index for this completion
	bool const bActiveDoubleBuffer[2] = { (0 != oUSART.Timestamp[0]), (0 != oUSART.Timestamp[1]) };
	
	uint32_t Selected;
	if ( false != (bActiveDoubleBuffer[0] & bActiveDoubleBuffer[1]) ) {
		if ( oUSART.Timestamp[0] < oUSART.Timestamp[1] )
			Selected = 0;
		else
			Selected = 1;
	}
	else if ( bActiveDoubleBuffer[0] )
		Selected = 0;
	else if ( bActiveDoubleBuffer[1] )
		Selected = 1;
	
	if ( NumDataFrames == ++oSendTxDoubleBuffer[Selected].FrameIndex )
	{
		// Mark current active buffer index free
		oUSART.Timestamp[Selected] = 0; // safe to reset here
		oUSART.bRequestDMA_DoubleBuffer[Selected] = false;
		oUSART.bDMABusy_DoubleBuffer[Selected] = false;
	}
}

#endif


